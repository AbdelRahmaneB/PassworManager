package ub.passwordmanager.tools.dataEncryption;

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * The role of this class is to Encrypt and Decrypt a String value
 * with a unique  key that only the user knows.
 * The function that can be used are
 * {@link #encryptData(String, String)} : to Encrypt the Data that we want.
 * {@link #decryptData(String, String)} : to Decrypt the Data that we want.
 * <p/>
 * Created by UB on 09/09/2016.
 */
public class DataEncryption {

    // The Hexadecimal values used to Encrypt & Decrypt the value
    private final static String HEX = "0123456789ABCDEF";

    /**
     * Our Instance for the factory using Singleton
     */
    private static DataEncryption INSTANCE;

    private DataEncryption() {
        // Required empty public constructor
    }

    /**
     * This method allow us to be sure that there will be only one instance of this class
     *
     * @return the instance of this class
     */
    public static DataEncryption getInstance() {
        if (INSTANCE == null) {
            synchronized (DataEncryption.class) {
                INSTANCE = new DataEncryption();
            }
        }
        return INSTANCE;
    }


    /**
     * This function helps to crypt the target value with a Key
     *
     * @param key            : Key used to crypt the value.
     * @param valueToEncrypt : the value that we want to Encrypt.
     * @return the Encrypted value.
     * @throws Exception
     */
    public String encryptData(String key, String valueToEncrypt) throws Exception {
        byte[] cryptKey = getEncryptKey(key.getBytes());
        byte[] result = mEncryptToByte(cryptKey, valueToEncrypt.getBytes());
        return mByteToHexadecimal(result);
    }


    /**
     * Function used to Decrypt the Data
     *
     * @param key            : Key used to crypt the value.
     * @param encryptedValue : the value that we want to Decrypt.
     * @return the value Decrypted.
     * @throws Exception
     */
    public String decryptData(String key, String encryptedValue) throws Exception {
        byte[] cryptKey = getEncryptKey(key.getBytes());
        byte[] enc = mStringToByte(encryptedValue);
        byte[] result = mDecryptToByte(cryptKey, enc);
        return new String(result);
    }

    /**
     * This function Convert a String to an array of bytes
     *
     * @param hexValue : the String to convert into bytes
     * @return an array of bytes made from a string
     */
    private byte[] mStringToByte(String hexValue) {
        int lengthValue = hexValue.length() / 2;
        byte[] result = new byte[lengthValue];
        for (int i = 0; i < lengthValue; i++)
            result[i] = Integer.valueOf(hexValue.substring(2 * i, 2 * i + 2), 16).byteValue();
        return result;
    }

    /**
     * Convert a Byte value to a Hexadecimal value.
     *
     * @param value : value to concert
     * @return the converted value.
     */
    private String mByteToHexadecimal(byte[] value) {
        if (value == null)
            return "";
        StringBuffer result = new StringBuffer(2 * value.length);
        for (byte val : value) {
            appendHex(result, val);
        }
        return result.toString();
    }

    /**
     * Function to generate our Key so that we may be able to Encrypt and Decrypt Data
     *
     * @param key : The base value for our Key
     * @return the a key that we can use to Encrypt & Decrypt.
     * @throws Exception
     */
    private byte[] getEncryptKey(byte[] key) throws Exception {
        KeyGenerator kGen = KeyGenerator.getInstance("AES");
        SecureRandom sr = SecureRandom.getInstance("SHA1PRNG", "Crypto");
        sr.setSeed(key);
        kGen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey sKey = kGen.generateKey();
        return sKey.getEncoded();
    }

    /**
     * Function used to Encrypt our value to a byte value
     *
     * @param key   : The used Key to Encrypt.
     * @param value : The value that we want to Encrypt.
     * @return the generated Byte value.
     * @throws Exception
     */
    private byte[] mEncryptToByte(byte[] key, byte[] value) throws Exception {
        SecretKeySpec sKeySpec = new SecretKeySpec(key, "AES");
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS7Padding", "BC");
        cipher.init(Cipher.ENCRYPT_MODE, sKeySpec);
        return cipher.doFinal(value);
    }

    /**
     * Function used to Decrypt our value to a byte value
     *
     * @param key            : The used Key to Encrypt.
     * @param encryptedValue : The value that we want to Decrypt.
     * @return the generated Byte value.
     * @throws Exception
     */
    private byte[] mDecryptToByte(byte[] key, byte[] encryptedValue) throws Exception {
        SecretKeySpec sKeySpec = new SecretKeySpec(key, "AES");
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS7Padding", "BC");
        cipher.init(Cipher.DECRYPT_MODE, sKeySpec);
        return cipher.doFinal(encryptedValue);
    }

    /**
     * Method of affixing the hexadecimal value.
     *
     * @param value : The value to affix.
     * @param mByte : Byte to use to affix the value.
     */
    private void appendHex(StringBuffer value, byte mByte) {
        value.append(HEX.charAt((mByte >> 4) & 0x0f)).append(HEX.charAt(mByte & 0x0f));
    }
}
